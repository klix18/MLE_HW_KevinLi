<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Voice Agent</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Gasoek+One&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Geist&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg-dark: #1C1430;
      --card-bg: #2A1F45;
      --accent: #846196;
      --white: #FFFFFF;
    }

    body {
      font-family: 'Geist', sans-serif;
      background-color: var(--bg-dark);
      color: var(--white);
      margin: 24px;
    }

    h1 {
      font-family: 'Gasoek One', sans-serif;
      font-size: 8rem;
      margin-top: -12px;
      margin-bottom: 12px;
      color: var(--white);
      text-shadow: 0 0 8px rgba(255,255,255,0.8);
    }

    .pill {
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(255,255,255,0.1);
      color: var(--accent);
    }

    .cards-row {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
    }

    .card {
      background-color: var(--card-bg);
      border-radius: 14px;
      padding: 16px;
      flex: 1 1 30%;
      display: flex;
      flex-direction: column;
      box-shadow: 0 0 12px rgba(255,255,255,0.05);
    }

    .card h3 {
      margin-top: 0;
      color: var(--accent);
      text-shadow: 0 0 6px rgba(0, 0, 0, 0.5);
    }

    button {
      padding: 10px 14px;
      border-radius: 10px;
      border: none;
      cursor: pointer;
      background: var(--accent);
      color: var(--bg-dark);
      font-weight: bold;
    }

    button.cancel-btn {
      background: #ff4d4d;
      color: var(--white);
    }

    button:disabled {
      opacity: .6;
      cursor: not-allowed;
    }

    audio {
      width: 100%;
      margin-top: 8px;
    }

    /* Chat styling */
    #chat {
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-height: 380px;
      overflow-y: auto;
      padding-right: 6px;
    }

    #chat::-webkit-scrollbar { width:8px }
    #chat::-webkit-scrollbar-thumb {
      background: rgba(186,237,245,.35);
      border-radius:8px;
    }
    #chat::-webkit-scrollbar-track { background: transparent }

    .msg {
      max-width: 680px;
      padding: 10px 12px;
      border-radius: 14px;
    }
    .msg.user {
      align-self: flex-end;
      background: rgba(232,240,255,0.15);
    }
    .msg.assistant {
      align-self: flex-start;
      background: rgba(255,255,255,0.08);
    }
    .msg .role {
      font-size: 12px;
      opacity: .7;
      margin-bottom: 4px;
    }

    /* Log styling */
    .log {
      margin-top: 10px;
      font-size: 12px;
      opacity: .85;
      white-space: pre-wrap;
      max-height: 160px;
      overflow-y: auto;
      padding-right: 6px;
    }
    .log::-webkit-scrollbar { width:8px }
    .log::-webkit-scrollbar-thumb {
      background: rgba(186,237,245,.25);
      border-radius:8px;
    }
    .log::-webkit-scrollbar-track { background: transparent }
  </style>
</head>
<body>
  <h1>ðŸŽ¤ The Voice Agent</h1>
  <span class="pill">POST /chat/ â†’ WAV reply</span>

  <div class="cards-row">
    <div class="card">
      <h3>Record from microphone</h3>
      <div class="row">
        <button id="recBtn">Start Recording</button>
        <button id="cancelBtn" class="cancel-btn" style="display:none;">Cancel</button>
        <span id="recStatus">Idle</span>
      </div>
      <audio id="userPreview" controls></audio>
    </div>

    <div class="card">
      <h3>Or upload an audio file</h3>
      <div class="row">
        <input id="fileInput" type="file" accept="audio/*" />
      </div>
    </div>

    <div class="card">
      <h3>Agent reply</h3>
      <audio id="agentAudio" controls></audio>
      <div class="log" id="log"></div>
    </div>
  </div>

  <div class="card" style="margin-top: 24px;">
    <h3>Chat history</h3>
    <div id="chat"></div>
  </div>

  <script>
    (async function () {
      // --- Elements ---
      const recBtn = document.getElementById('recBtn');
      const cancelBtn = document.getElementById('cancelBtn');
      const userPreview = document.getElementById('userPreview');
      const agentAudio = document.getElementById('agentAudio'); // kept for non-stream fallbacks
      const recStatus = document.getElementById('recStatus');
      const log = document.getElementById('log');
      const chatEl = document.getElementById('chat');
      const fileInput = document.getElementById('fileInput');
    
      // --- State ---
      let mediaRecorder = null;
      let chunks = [];
      let recording = false;
      let partialText = "";
      const logBuffer = [];
    
      // --- Utils ---
      function logMsg(msg){
        logBuffer.unshift(msg);
        if (logBuffer.length > 200) logBuffer.length = 200;
        log.textContent = logBuffer.join('\n');
      }
      function escapeHtml(s){
        return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;');
      }
      async function refreshHistory(){
        try{
          const res = await fetch('/history');
          if(!res.ok) return;
          const hist = await res.json();
          renderHistory(hist);
        }catch{}
      }
      // Newest-first history
      function renderHistory(items){
        chatEl.innerHTML = '';
        const reversed = [...items].reverse();
        for (const m of reversed){
          const wrap = document.createElement('div');
          wrap.className = `msg ${m.role}`;
          wrap.innerHTML = `
            <div class="role">${m.role === 'user' ? 'You' : 'Assistant'}</div>
            <div class="text">${escapeHtml(m.content)}</div>
          `;
          chatEl.appendChild(wrap);
        }
        if (recording && partialText){
          const wrap = document.createElement('div');
          wrap.className = 'msg user';
          wrap.innerHTML = `<div class="role">You (speakingâ€¦)</div><div class="text">${escapeHtml(partialText)}</div>`;
          chatEl.insertBefore(wrap, chatEl.firstChild);
        }
      }
    
      // --- Streaming audio pipeline (multipart x-mixed-replace) ---
      async function sendStreamAndPlay(formData){
        const res = await fetch('/chat/stream', { method: 'POST', body: formData });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
    
        const reader = res.body.getReader();
        const enc = new TextEncoder();
        const dec = new TextDecoder();
    
        const boundary = 'wavchunk';
        const boundaryLine = enc.encode(`--${boundary}`);
        const headerTerm = enc.encode('\r\n\r\n');
    
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        // ensure audio starts (Safari/iOS) â€” this function is always called from a user gesture (stop/upload)
        try { await audioCtx.resume(); } catch {}
    
        // schedule chunks back-to-back
        let lastEnd = audioCtx.currentTime;
    
        async function playWavBytes(bytes){
          const arrayBuf = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
          const audioBuf = await audioCtx.decodeAudioData(arrayBuf);
          const src = audioCtx.createBufferSource();
          src.buffer = audioBuf;
          src.connect(audioCtx.destination);
          const startAt = Math.max(audioCtx.currentTime, lastEnd + 0.02);
          src.start(startAt);
          lastEnd = startAt + audioBuf.duration;
        }
    
        // helper: find sequence in a Uint8Array
        function indexOfSeq(hay, needle, from=0){
          outer: for (let i = from; i <= hay.length - needle.length; i++){
            for (let j = 0; j < needle.length; j++){
              if (hay[i+j] !== needle[j]) continue outer;
            }
            return i;
          }
          return -1;
        }
    
        // stream buffer
        let buf = new Uint8Array(0);
    
        // read loop
        while (true){
          const { value, done } = await reader.read();
          if (done) break;
    
          // append to buf
          const nb = new Uint8Array(buf.length + value.length);
          nb.set(buf, 0); nb.set(value, buf.length);
          buf = nb;
    
          // extract as many complete parts as possible
          while (true){
            // find boundary start
            let bIdx = indexOfSeq(buf, boundaryLine);
            if (bIdx === -1){
              // try discarding leading noise if buffer grows huge
              if (buf.length > 2_000_000) buf = buf.slice(-256_000);
              break;
            }
            // boundary must be followed by CRLF
            const afterBoundary = bIdx + boundaryLine.length;
            if (afterBoundary + 2 > buf.length) break; // need more data
            // find header end
            const hStart = afterBoundary + 2; // skip \r\n
            const hEnd = indexOfSeq(buf, headerTerm, hStart);
            if (hEnd === -1) break; // need more data
    
            // parse headers
            const headersBytes = buf.slice(hStart, hEnd);
            const headersText = dec.decode(headersBytes);
            const isEnd = headersText.includes('--') || headersText.trim() === '';
            if (isEnd){
              // end of stream marker
              buf = new Uint8Array(0);
              break;
            }
            // content length (required)
            const mLen = headersText.match(/Content-Length:\s*(\d+)/i);
            const contentLength = mLen ? parseInt(mLen[1], 10) : null;
            if (!contentLength){ 
              // try to skip malformed header
              buf = buf.slice(hEnd + headerTerm.length);
              continue;
            }
    
            // body start/end
            const bodyStart = hEnd + headerTerm.length;
            const bodyEnd = bodyStart + contentLength;
            if (bodyEnd > buf.length) break; // need more data
    
            const body = buf.slice(bodyStart, bodyEnd);
    
            // advance buffer; optional trailing CRLF after body
            let restStart = bodyEnd;
            if (restStart + 2 <= buf.length && buf[restStart] === 13 && buf[restStart+1] === 10){
              restStart += 2;
            }
            buf = buf.slice(restStart);
    
            // decide: JSON meta (user text) vs audio
            const isJson = body.length && body[0] === 0x7B; // '{'
            if (isJson){
              try {
                const meta = JSON.parse(dec.decode(body));
                if (meta.user){
                  // prepend the user text to history view immediately
                  await refreshHistory();
                  logMsg('User (ASR): ' + meta.user);
                }
              } catch {}
            } else {
              // play this WAV chunk
              try {
                await playWavBytes(body);
              } catch (e) {
                logMsg('Decode error: ' + e.message);
              }
            }
          }
        }
    
        // after stream ends, refresh history
        await refreshHistory();
      }
    
      // --- Recording controls ---
      recBtn.onclick = async () => {
        if (!recording) {
          await startRecording();
        } else {
          await stopRecording(true); // stop and send
        }
      };
    
      cancelBtn.onclick = async () => {
        if (!recording) return;
        await stopRecording(false); // stop without sending
        // clear local UI state
        chunks = [];
        partialText = "";
        userPreview.src = '';
        recStatus.textContent = 'Recording canceled â€“ nothing sent.';
        recBtn.textContent = 'Start Recording';
        cancelBtn.style.display = 'none';
        logMsg('Recording canceled â€“ nothing sent.');
        await refreshHistory();
      };
    
      async function startRecording(){
        try{
          const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
          const mime = MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' : '';
          mediaRecorder = new MediaRecorder(stream, mime ? { mimeType: mime } : {});
          chunks = [];
          partialText = "";
          recording = true;
          recBtn.textContent = 'Stop Recording';
          cancelBtn.style.display = 'inline-block';
          recStatus.textContent = 'Recordingâ€¦';
          logMsg('Recording started');
    
          mediaRecorder.ondataavailable = async (e) => {
            if (!e.data || !e.data.size) return;
            chunks.push(e.data);
            // partial ASR for live captions
            try{
              const fd = new FormData();
              fd.append('file', e.data, 'chunk.webm');
              const r = await fetch('/asr-chunk', { method:'POST', body: fd });
              if (r.ok){
                const data = await r.json();
                if (data.partial){
                  partialText = data.partial;
                  refreshHistory();
                }
              }
            }catch{}
          };
    
          mediaRecorder.start(750); // ms timeslice
        }catch(err){
          logMsg('Mic error: ' + err.message);
        }
      }
    
      async function stopRecording(send){
        if (!mediaRecorder) return;
        recording = false;
        recBtn.textContent = 'Start Recording';
        recStatus.textContent = send ? 'Processingâ€¦' : 'Idle';
        mediaRecorder.stop();
        mediaRecorder.stream.getTracks().forEach(t => t.stop());
        cancelBtn.style.display = 'none';
    
        if (!send) return;
    
        // Build a single blob of the whole utterance and stream it to server
        const fullBlob = new Blob(chunks, { type: mediaRecorder.mimeType || 'audio/webm' });
        userPreview.src = URL.createObjectURL(fullBlob);
        logMsg('Sending full audio to /chat/streamâ€¦');
    
        const fd = new FormData();
        fd.append('file', fullBlob, 'full.webm');
    
        try{
          await sendStreamAndPlay(fd);
          recStatus.textContent = 'Idle';
          logMsg('Agent streaming reply finished.');
          partialText = "";
        }catch(e){
          logMsg('Stream error: ' + e.message);
          recStatus.textContent = 'Error';
        }
      }
    
      // --- File upload: auto-send via streaming endpoint ---
      fileInput.onchange = async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        userPreview.src = URL.createObjectURL(file);
        logMsg('Sending uploaded file to /chat/streamâ€¦');
        const fd = new FormData();
        fd.append('file', file, file.name || 'upload.webm');
        try{
          await sendStreamAndPlay(fd);
          logMsg('Agent streaming reply finished (upload).');
          await refreshHistory();
        }catch(e){
          logMsg('Stream error: ' + e.message);
        }
      };
    
      // Initial history
      await refreshHistory();
    })();
    </script>
    
</body>
</html>

